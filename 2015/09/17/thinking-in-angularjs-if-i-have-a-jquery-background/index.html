<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>由jQuery到AngularJS的思维转变[翻译] | One Step To</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="baidu-site-verification" content="dTVxXStghn" />
  <meta name="description" content="由于近几年AngularJS的火爆,许多前端工作者渐渐也都把目光移到了如何使用这款框架上,然而作为先前在市场占大多数使用份额的jQuery,如何快速从jQuery的思维转化为Angular的思维是个困扰诸多前端爱好者的问题.故作此文做一点小小建议.
1.不要先设计你的页面,再进行DOM操作在jQuery中,它让我们很容易的去操作DOM(增加或减少页面内容),不用太多的考虑兼容性问题,所以我们开发的">
<meta property="og:type" content="article">
<meta property="og:title" content="由jQuery到AngularJS的思维转变[翻译]">
<meta property="og:url" content="http://onestepto.cn/2015/09/17/thinking-in-angularjs-if-i-have-a-jquery-background/index.html">
<meta property="og:site_name" content="One Step To">
<meta property="og:description" content="由于近几年AngularJS的火爆,许多前端工作者渐渐也都把目光移到了如何使用这款框架上,然而作为先前在市场占大多数使用份额的jQuery,如何快速从jQuery的思维转化为Angular的思维是个困扰诸多前端爱好者的问题.故作此文做一点小小建议.
1.不要先设计你的页面,再进行DOM操作在jQuery中,它让我们很容易的去操作DOM(增加或减少页面内容),不用太多的考虑兼容性问题,所以我们开发的">
<meta property="og:updated_time" content="2015-10-13T03:25:57.911Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="由jQuery到AngularJS的思维转变[翻译]">
<meta name="twitter:description" content="由于近几年AngularJS的火爆,许多前端工作者渐渐也都把目光移到了如何使用这款框架上,然而作为先前在市场占大多数使用份额的jQuery,如何快速从jQuery的思维转化为Angular的思维是个困扰诸多前端爱好者的问题.故作此文做一点小小建议.
1.不要先设计你的页面,再进行DOM操作在jQuery中,它让我们很容易的去操作DOM(增加或减少页面内容),不用太多的考虑兼容性问题,所以我们开发的">
  
    <link rel="alternative" href="/atom.xml" title="One Step To" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/user_ic.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">One Step To</a></h1>
		</hgroup>

		
		<p class="header-subtitle">做人不装逼那跟咸鱼有什么区别</p>
		
		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">存档</a></li>
				        
							<li><a href="/about">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							<div align="center"><img border="0" src="http://cc.amazingcounters.com/counter.php?i=3194371&c=9583426" alt="AmazingCounters.com"></div>
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AngularJS/" style="font-size: 20px;">AngularJS</a> <a href="/tags/Css/" style="font-size: 10px;">Css</a> <a href="/tags/Javascript/" style="font-size: 10px;">Javascript</a> <a href="/tags/Requirejs/" style="font-size: 10px;">Requirejs</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css3/" style="font-size: 10px;">css3</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/指令/" style="font-size: 10px;">指令</a> <a href="/tags/杂记/" style="font-size: 10px;">杂记</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">One Step To</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/user_ic.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">One Step To</h1>
			</hgroup>
			
			<p class="header-subtitle">做人不装逼那跟咸鱼有什么区别</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">存档</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-thinking-in-angularjs-if-i-have-a-jquery-background" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/17/thinking-in-angularjs-if-i-have-a-jquery-background/" class="article-date">
  	<time datetime="2015-09-17T05:15:00.000Z" itemprop="datePublished">2015-09-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      由jQuery到AngularJS的思维转变[翻译]
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AngularJS/">AngularJS</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于近几年AngularJS的火爆,许多前端工作者渐渐也都把目光移到了如何使用这款框架上,然而作为先前在市场占大多数使用份额的jQuery,如何快速从jQuery的思维转化为Angular的思维是个困扰诸多前端爱好者的问题.故作此文做一点小小建议.</p>
<h1 id="1-不要先设计你的页面,再进行DOM操作">1.不要先设计你的页面,再进行DOM操作</h1><p>在jQuery中,它让我们很容易的去操作DOM(增加或减少页面内容),不用太多的考虑兼容性问题,所以我们开发的第一步往往会先是设计一个页面,然后再去动态得去改变它的内容.</p>
<p>但在AngularJS中,你必须先在你的心中构建应用,而不是从”我有多少块DOM,我要让这些DOM去做XX”这样的思路去思考,你必须从你的实现去思考,然后开始设计你的应用,最后再设计你的视图,这也是AngularJS数据驱动概念的核心.</p>
<h1 id="2-First_think_in_AngularJS">2.First think in AngularJS</h1><p>同样的,不要想着说这里有块功能我可以用jQuery来实现,我只需要把AngularJS放在顶层,然后在控制器中用JQ去操作DOM,这对于那些刚刚接触AngularJS的人是非常有诱惑性的,毕竟这是他们比较熟悉的在JQ里的实现,这也是为什么一些AngularJS大牛建议那些AngularJS新手开发者直到能完全的使用”Angular Way”前,一点都不要用jQuery的原因.</p>
<a id="more"></a>
<p>我曾看到过不少开发者喜欢把一些jQuery中几百行的插件代码引入AngularJS的代码中,通过一个<code>$apply</code>回调在AngularJS中使用,这样的代码将会变得十分混乱可读性差而且复杂.大部分的情景下,jQuery中的插件都是可以在Angular中的重写的,这将会让很多代码看起来更加易于理解更加可读.</p>
<p>总的来说:当你解决问题时,<code>First think in AngularJS</code>;如果你想不到解决方法,你可以到社区中讨论,到谷歌百度中查找别人的解决方案;如果还是没有比较简单的解决方案,而你又觉得用jQuery来实现更加可行,你可以大胆使用,但千万别让jQuery成为你代码中的支柱,否则你将永远驾驭不了AngularJS;</p>
<h1 id="3-用架构的方式去构建你的应用">3.用架构的方式去构建你的应用</h1><p>AngularJS设计之初就特别适合来做单页应用,首先你要清楚单页应用是应用,而不是单纯的网站,因此你在作为一个前端开发者思考的同时还需加入一点服务端开发人员的考虑,你必须考虑好你的应用将切分成多少单独的部分,每个部分的可拓展性,以及你的测试模块.</p>
<p>到底如何去做?如何去<code>think in AngularJS</code>?与jQuery对比这里有一些比较常见的原则.</p>
<h3 id="从你自己的’官方模版’去思考">从你自己的’官方模版’去思考</h3><p>在JQ中,我们动态的改变视图,我们可以用一个下拉菜单的函数来代替这里的<code>ul</code>,像这样:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"main-menu"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"active"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#/home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#/menu1"</span>&gt;</span>Menu 1<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#/sm1"</span>&gt;</span>Submenu 1<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#/sm2"</span>&gt;</span>Submenu 2<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#/sm3"</span>&gt;</span>Submenu 3<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#/home"</span>&gt;</span>Menu 2<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在JQ中,我们在应用中构建一个函数,然后可以想下面这样使用:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">'.main-menu'</span>).dropdownMenu();</span><br></pre></td></tr></table></figure>
<p>但你看到视图时,你并不能立刻明显的知道一个DOM元素这里会有什么函数,对于一些小的应用,这是很好的,但对于一些 <code>non-rivial</code>(语义性强) 应用,这时整个页面可能就会变得开始难以理解并且难以维护.</p>
<p>在AngularJS中,官方推荐的方式是一种 <code>view-based</code>基于视图的函数,我们的<code>ul</code>可以声明为如下的方式:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"main-menu"</span> <span class="attribute">dropdown-menu</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这两种方式做了同样的事情,但AngularJS的视图让我没能通过看部分的模块便能知道它所期望的操作.无论什么时候一个开发团队的新成员加入,他都能通过看这些很快理解有一个指令<code>dropdownMenu</code>绑定在<code>ul</code>这个元素上,他不需要去依靠直觉猜测答案或者是去看任何代码.视图告诉了他一切.可见这让开发更加清晰.</p>
<p>AngularJS 的新手开发者经常问的一个问题:”我如何找到一个页面中特定种类的元素然后添加指令到上面”,可能很多开发者在被回答说不要这么做的时候很疑惑,但之所以不建议这样做的原因是这像是一种一般jQuery一般AngularJS的方式.这不会让程序良好的运行,视图是你的官方模版,向外用指令来表明自己,你不要再尝试去修改页面的DOM,添加指令到你的视图中实现功能,这将会让整个应用更加清晰.</p>
<p>这也是jQuery与AngularJS思考模式的不同,我们用jQuery写程序可能会反复修改页面上的DOM,而AngularJS则是通过增加指令的方式来让页面视图更加清晰合理.</p>
<h2 id="数据绑定">数据绑定</h2><p>双向数据绑定是AngularJS最令人振奋的特性之一,这让我们不再需要过多的DOM操作,AngularJS会自动的更新你的视图,因此你不在必须像jQuery中去操作DOM,我们响应事件,然后更新内容,如下:</p>
<p>In jQuery:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">'/myEndpoint.json'</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params"> data, status </span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'ul#log'</span>).append(<span class="string">'&lt;li&gt;Data Received!&lt;/li&gt;'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>视图如下:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul <span class="type">class</span>=<span class="string">"messages"</span> <span class="property">id</span>=<span class="string">"log"</span>&gt;&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果此时我们还需要删除其中的某条数据,或是编辑等操作,或是想去修改对应的DOM结构,我们又需要再写一遍代码去操作DOM,我们也将难以从DOM中进行测试,每次我们想改变我们的显示可能都需要对代码做出修改.如何脱离DOM来测试我们的逻辑?又如果我们想改变一些页面表现?</p>
<p>在AngularJS中,我们可以这样做:</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"messages"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"entry in log"</span>&gt;</span></span><span class="expression">&#123;&#123; <span class="variable">entry.msg</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>如果想修改DOM结构,我们可以这样写:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"messages"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"alert"</span> ng-<span class="keyword">repeat</span>=<span class="string">"entry in log"</span>&gt;</span><br><span class="line">        &#123;&#123; entry.msg &#125;&#125;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果这是我们用了Bootstrap 的一些样式,我们不再需要去改变控制器中的代码,而可以直接在html的DOM中直接进行修改,无聊何时我们的<code>log</code>发生了更改,视图都将会自动的改变!</p>
<p>数据绑定是双向的,这里我没有展示.因此这里的<code>log</code>可以在视图中实时进行修改,如<code>&lt;input ng-model=&quot;entry.msg&quot; /&gt;</code>.</p>
<h2 id="更加清晰的模块分层">更加清晰的模块分层</h2><p>在jQuery中,我们可以把DOM看作是一个模块,但在AngularJS中,我们有分开的模块层,我们可以用任何我们想要的方式管理这些模块,完全独立于视图.这帮助我们进行上文所说的数据绑定,维护,<a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="external">分离关注点</a>,已经更加可测试.</p>
<h2 id="分离你的关注点">分离你的关注点</h2><p>所有上文提到的其实都有一个共同的主题:让你的关注点分离,你的视图想你的模版那样表现(to do what you supposed);你的<code>model</code>代表你的数据;你有一个服务层来执行可重复执行的任务;你在你的指令中执行DOM操作丰富你的视图;然后你把这些通过控制器联系在一起.这也是我们经常听到或用到的模块化的思想.关键的还是这种特性让前端测试变得更加方便简单.</p>
<h2 id="依赖注入">依赖注入</h2><p>依赖注入<a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="external">dependency injection</a> (DI)帮助我们更好的分离模块,如果你用过服务端语言(JAVA/PHP),你大概已经对这个概念很清楚了,但如果你是一个从jQuery转学AngularJS的前端开发者,这个概念可能看起来是愚蠢而且多余的(实则不是).</p>
<p>从一个长远的观点看,依赖注入意味这你可以非常自由的从其他任何组件(components)声明组件,请求组件的一个实例.你不必要去知道加载权限或者文件位置,或者任何像这样的事情.这种力量可能在前端开发上很难明显体现,但在测试中的作用是十分显著的.</p>
<p>再让我们说说应用,我们请求一个从服务端通过REST API返回并且取决与应用状态和本地存储的服务.但我们在控制器中运行测试时,我们不想去与服务交互,毕竟我们仅仅测试控制器.我们可以添加一个与源组件同名的<code>mock</code>服务,然后注入器会确认我们的控制器是否自动的获得了空壳(mock)-我们的控制器不需要知道两者间(mock和original component)的不同</p>
<p>深入就是测试的话了……</p>
<h1 id="4-测试驱动的开发模式">4.测试驱动的开发模式</h1><p>这个实际上 架构的第三部分,但它的重要性让我把它放到了我最后的讨论上.</p>
<p>纵观所有你用过,看过或写过的jQuery插件,其中有多事是有伴随的测试模块?没有多少,因为测试在jQuery中不怎么好写,但AngularJS则是是否受用的.</p>
<p>在jQuery中,唯一的方法去测试常常是重复创建一个组件独立与简单的页面(sample/demo page)然后我们的测试重复执行DOM操作.因此我们必须分开开发我们的组件,然后再集成到我们的应用中.这明显不是聪明人选择的做法!用jQuery开发需要太多时间,因此我们更倾向于使用测试驱动的开发模式.</p>
<p>在AngularJS中,我们拥有分离的关注点(separation of concerns),我们可以在AngularJS中实现测试驱动的开发模式.举个例子,我们创建一个非常简单的指令来表明我们的菜单现在的路由状态是在哪.我们在应用中声明我们想要的视图:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/hello"</span> <span class="attribute">when-active</span>&gt;</span>Hello<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Okay,现在我们可以写一个测试给我们这个不存在的<code>when-active</code>指令:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it( <span class="string">'should add "active" when the route changes'</span>, inject(<span class="keyword">function</span>() &#123;</span><br><span class="line">    var elm = <span class="variable">$compile</span>( <span class="string">'&lt;a href="/hello" when-active&gt;Hello&lt;/a&gt;'</span> )( <span class="variable">$scope</span> );</span><br><span class="line"></span><br><span class="line">    <span class="variable">$location</span>.path(<span class="string">'/not-matching'</span>);</span><br><span class="line">    expect( elm.hasClass(<span class="string">'active'</span>) ).toBeFalsey();</span><br><span class="line"></span><br><span class="line">    <span class="variable">$location</span>.path( <span class="string">'/hello'</span> );</span><br><span class="line">    expect( elm.hasClass(<span class="string">'active'</span>) ).toBeTruthy();</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>但我们运行我们的测试,我们可以query它是否失败.只有测试通过我们现在才能创建我们的指令:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.directive( <span class="string">'whenActive'</span>, <span class="keyword">function</span> ( <span class="variable">$location</span> ) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        scope: true,</span><br><span class="line">        link: function ( scope, element, attrs ) &#123;</span><br><span class="line">            scope.<span class="variable">$on</span>( <span class="string">'$routeChangeSuccess'</span>, function () &#123;</span><br><span class="line">                if ( <span class="variable">$location</span>.path() == element.attr( <span class="string">'href'</span> ) ) &#123;</span><br><span class="line">                    element.addClass( <span class="string">'active'</span> );</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    element.removeClass( <span class="string">'active'</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们的测试现在通过了,菜单像我们期望的样子展现.开发即可复用又是测试驱动的,不明觉厉!</p>
<h1 id="5-指令不是打包jQuery代码的天堂">5.指令不是打包jQuery代码的天堂</h1><p>你可能经常听到”只在一个指令中操作DOM”.这是必要的,这样看待指令也没什么错~</p>
<p>让我们深入一点…</p>
<p>一些指令只是修饰一些我们已有的视图,可以考虑用<code>ngClass</code>,除非一些时候必须进行DOM操作,否则基本上AngularJS中的内置指令足矣.但如果一个带有模版(template)的’工具’指令,它就需要用分离关注点的思想来对待了.这个时候工具的大部分功能代码应该独立地在link或者控制器函数中实现.</p>
<p>AngularJS内置的工具指令让我们构建一些功能非常简单;我们能通过<code>ngClass</code>方便的更新class;通过<code>ngModel</code>实现双向数据绑定;通过<code>ngShow</code>和<code>ngHide</code>实现显示和隐藏元素;还有很多…包括我们自己写的.换句话说,我们可以做种类繁多的功能而不需要进行DOM才做.越少的DOM操作,指令就越容易去测试,他们的设计越简单,未来的更改也会更加简单.</p>
<p>我见过许多AngularJS开发新手常常使用指令当作编写大量jQuery代码的地方.换句话说,他们就像”既然我不能在控制器中做指令操作,那我可以把代码写在指令中”.当然这比起控制器中写好很多,但显然还是错的.</p>
<p>想想我们第三部分讨论的,尽管我们会把DOM操作放在指令中,但我们依然希望能够以AngularJS的方式去写.有时候压根没必要去做任何DOM操作,也有一些比你相信时候,DOM操作是必要的,但这比你想象中的要少得多!在你要在你的应用的任何地方进行DOM操作时,问你自己是否真的需要.可能还有更好的方式.</p>
<p>这里有个简单的例子展示我经常看到的一种JQ模式.我们需要一个开关的按钮.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.directive( <span class="string">'myDirective'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        template: <span class="string">'&lt;a class="btn"&gt;Toggle me!&lt;/a&gt;'</span>,</span><br><span class="line">        link: <span class="function"><span class="keyword">function</span> (<span class="params"> scope, element, attrs </span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> on = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            $(element).click( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                on = !on;</span><br><span class="line">                $(element).toggleClass(<span class="string">'active'</span>, on);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里的一些错误如下:</p>
<p>1.jQuery不是必要的,这里做的事情我们并不是一定要用到jQuery.<br>2.即便在我们的页面中我们已经引入过了jQuery,但没有理由我们要在这里去用它;我们能简单的使用<code>angular.element</code>,这样我们的组件就算放到了一个没有引入jQuery的项目中依旧可以使用.<br>3.假设jQuery是对这个指令的运行是必须的,jqLite (<code>angular.element</code>) 当jQuery加载后也已经使用它了,我们不需要使用<code>$</code>-我们仅仅使用<code>angular.element</code>.<br>4.像第三点提到的那样,这里的jqLite对象不需要用<code>$</code>包裹*而且<code>link</code>函数中的<code>element</code>已经是一个jQuery对象了!<br>5.就如上面提到的,为何要把模版混入我们的逻辑之中.</p>
<p>这个指令可以像下面这样重写,你会发现简单很多~</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.directive( 'myDirective', function () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        scope: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">template</span>: '&lt;a class=<span class="string">"btn"</span> ng-class=<span class="string">"&#123;active: on&#125;"</span> ng-click=<span class="string">"toggle()"</span>&gt;<span class="type">Toggle</span> me!&lt;/a&gt;',</span><br><span class="line">        link: function ( scope, element, attrs ) &#123;</span><br><span class="line">            scope.on = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            scope.toggle = function () &#123;</span><br><span class="line">                scope.on = !scope.on;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>值得重复一提的是,模版(<code>template</code>)的职责就是模版,因此你(或者你的用户)可以简单的替换它成为其他必要的样式,而逻辑永远不能被触碰到,而且逻辑也是不可重用的.</p>
<p>这里还有其他很多好处,测试会变得简单!不管模版里有什么,指令内部的API永远不会被触碰,因此重构是简单的.你可以随意改变模版而不会触及指令.不管你对它做了什么修改,你的测试都依旧会通过.</p>
<p>指令如果不是jQuery-like代码的集合,那会是什么?指令实际上是HTML的拓展(extensions of HTML),如果HTML不能做你需要做的一些事情,你写一个指令为你做这件事,然后把它当作HTML中的一部分使用.</p>
<p>另一方面,如果AngularJS遇到不能做的一些事情,可以考虑配合<code>ngClick</code>,<code>ngClass</code>,等指令实现</p>
<h2 id="总结">总结</h2><p>当你开始使用AngularJS,不要在去使用jQuery,也不要去引入jQuery,当你遇到一些你已经用jQuery解决过的问题,在你即将使用<code>$</code>之前,尝试去思考如果用AngularJS的方式去实现.如果不知道,问!反复问,你最终一定能得到不需要jQuery来实现的最佳解决方法.</p>
<p>参考:<a href="http://stackoverflow.com/questions/14994391/thinking-in-angularjs-if-i-have-a-jquery-background?rq=1" target="_blank" rel="external">http://stackoverflow.com</a></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/10/16/think-2015-10-16/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          生日随笔
        
      </div>
    </a>
  
  
    <a href="/2015/09/07/remove-unnecessary-watcher/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">AngularJS实践之优化你的$watch</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>




<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="thinking-in-angularjs-if-i-have-a-jquery-background" data-title="由jQuery到AngularJS的思维转变[翻译]" data-url="http://onestepto.cn/2015/09/17/thinking-in-angularjs-if-i-have-a-jquery-background/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"onestepto"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 One Step To
    	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>